---
title: Hibernate 框架
date: 2019-12-08 21:23:46
tags:
---
# Hibernate 框架

### 一，什么是Hibernate

> Hibernate 是一个开源框架，它是对象关联关系映射的框架，它对 JDBC 做了轻量级的封装，使 java 程序员可以使用面向对象的思想来操纵数据库。

说白了，hibernate就是一个轻量级、全自动的orm框架，它将pojo与数据库建立映射关系，程序员可以使用hql语句对数据库数据表进行交互操作。

### 二，什么是ORM

> 对象关系映射（英语：Object Relation Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。
>
> 对象-关系映射，是随着面向对象的软件开发方法发展而产生的。面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。
>
> ORM模型的简单性简化了数据库查询过程。使用ORM查询工具，用户可以访问期望数据，而不必理解数据库的底层结构。



![20170320230433928](C:\Users\Administrator\Desktop\20170320230433928.png)

简单来说，我们使用ORM可以将我们的对象(或类)去进行映射，使得我们可以去操作对象就能完成对表的操作。

### 为什么使用Hibernate（Hibernate的优点）

- 对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码

- Hibernate 是一个基于 JDBC 的主流持久化框架，是一个优秀的 ORM 实现。它很大程度的简化了 DAO 层的编码工作

- Hibernate 使用 Java 反射机制，而不是字节码增强程序来实现透明性

- Hibernate 的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系

  ---

  

  简单来说：hibernate把数据库的增删查改代码封装成自己的hql语法，大大简化了写sql语法的时间，使用**反射机制来提高代码灵活性和可配置性，降低代码耦合**，使用映射提高了代码的灵活性、非侵入性、移植性。

###  Hibernate的缺点

- 无法对 SQL 进行优化
- 框架中使用ORM原则, 导致配置过于复杂
- 执行效率和原生的 JDBC 相比偏差:，特别是在批量数据处理的时候
- 不支持批量修改、删除

---

 	简单说：由于封装的太好了，反而不好使用原生sql语句对数据库优化，ORM原则需要大量的配置，假如有几百张表，需要配置很久。执行效率慢是hibernate默认延迟加载，实际开发中有些情况下会关闭延迟加载（lazy=false）这时大大影响效率，打个比方在“一对多”的关系映射中，查询“一”的一方，那么多的“一方”也会立刻加载出来，如果“一”的一方关联了大量的数据，那么“多”的一方都会被查询出来，造成不必要的资源浪费。

### Hibernate 的缓存机制

**Hibernate 缓存的作用**：Hibernate 是一个持久层框架，经常访问物理数据库，为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能。缓存内的数据是对物理数据源中数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。

白话： 假设一万个人需要知道一款手机的价格，那么就需要hibernate去访问数据库查询这款手机的价格，大量的访问数据库导致数据库宕机或其他问题。那么hibernate把这个结果缓存下来。就可以不需要访问数据库来直接给用户返回这款手机的价格。

**Hibernate 缓存分类**：Hibernate 缓存包括两大类：Hibernate 一级缓存和 Hibernate 二级缓存。

> Hibernate 一级缓存又称为“Session的缓存”，它是内置的，不能被卸载。由于 Session 对象的生命周期通常对应一个数据库事务或者一个应用事务，因此它的缓存是事务范围的缓存。一级缓存是必需的，不允许而且事实上也无法卸除。在第一级缓存中，持久化类的每个实例都具有唯一的 OID。

> Hibernate 二级缓存又称为“SessionFactory的缓存”，由于 SessionFactory 对象的生命周期和应用程序的整个过程对应，因此 Hibernate 二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。第二级缓存是可选的，是一个可配置的插件，在默认情况下，SessionFactory 不会启用这个插件
---

**Q:什么样的数据适合存放到第二级缓存中 ？**

**A:**很少被修改的数据；不是很重要的数据，允许偶尔出现并发；不会被并发访问的数据；常量数据

**Q:不适合存放到第二级缓存的数据  ？**

**A:**经常被修改的数据；绝对不允许出现并发访问的数据，如财务数据；与其他应用共享的数据

**Q:Hibernate 查找对象如何应用缓存 ？**

**A:**当 Hibernate 根据 ID 访问数据对象的时候，首先从 Session 一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；如果都查不到，再查询数据库，把结果按照 ID 放入到缓存，删除、更新、增加数据的时候，同时更新缓存。

### Hibernate 懒加载

> 懒加载(lazy)就是延迟加载。至于为什么要用懒加载呢，就是当我们要访问的数据量过大时，明显用缓存不太合适，因为内存容量有限，为了减少并发量，减少系统资源的消耗，我们让数据在需要的时候才进行加载，这时 Hibernate 用懒加载机制来弥补这种缺陷，但是这只是弥补而不是用了懒加载总体性能就提高了。

- 对于 Hibernate get 方法，Hibernate 会确认一下该 id 对应的数据是否存在，首先在 session 缓存中查找，然后在二级缓存中查找，还没有就查询数据库，数据库中没有就返回 null。

- Hibernate load 方法加载实体对象的时候，根据映射文件上类级别的 lazy 属性的配置(默认为true)，分情况讨论：
  - 若为 true，则首先在 Session 缓存中查找，看看该 id 对应的对象是否存在，不存在则使用延迟加载，返回实体的代理类对象(该代理类为实体类的子类，由CGLIB动态生成)。等到具体使用该对象(除获取OID以外)的时候，再查询二级缓存和数据库，若仍没发现符合条件的记录，则会抛出一个 ObjectNotFoundException。
  - 若为false，就跟 Hibernateget 方法查找顺序一样，只是最终若没发现符合条件的记录，则会抛出一个 ObjectNotFoundException。

这里 get 和 load 有两个重要区别：

- 如果未能发现符合条件的记录， Hibernate get 方法返回 null，而 load 方法会抛出一个 ObjectNotFoundException；
- load 方法可返回没有加载实体数据的代理类实例，而 get 方法永远返回有实体数据的对象。

总之根本区别 hibernate 对于 load 方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于 get 方 法，hibernate 一定要获取到真实的数据，否则返回 null

### Hibernate 与  MyBatis 的区别

- **相同点**   

  1. Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。

     其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持JDBC和JTA事务处理。

- **不同点**

  1. <font color='red'>hibernate是全自动，而mybatis是半自动</font>

     hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。

  2. <font color='red'>hibernate数据库移植性远大于mybatis</font>

     hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。

  3. <font color='red'>hibernate拥有完整的日志系统，mybatis则欠缺一些</font>

     hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。

  4. <font color='red'>mybatis相比hibernate需要关心很多细节<

     hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。

  5. <font color='red'>mybatis相比hibernate需要关心很多细节</font>

     hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。

  6. <font color='red'>缓存机制上，hibernate要比mybatis更好一些</font>

     MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。

     而Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。

- **Hibernate 优势**
   Hibernate 的 DAO 层开发比 MyBatis 简单，Mybatis 需要维护 SQL 和结果映射。
   Hibernate 对对象的维护和缓存要比 MyBatis 好，对增删改查的对象的维护要方便。
   Hibernate 数据库移植性很好，MyBatis 的数据库移植性不好，不同的数据库需要写不同 SQL。
   Hibernate 有更好的二级缓存机制，可以使用第三方缓存。MyBatis 本身提供的缓存机制不佳。

- **Mybatis 优势**
   MyBatis 可以进行更为细致的 SQL 优化，可以减少查询字段。
   MyBatis容易掌握，而Hibernate门槛较高。

- **总结**

  1. **两者相同点** 
     Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。

  2. **两者不同点** 
     Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。而MyBatis在使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。

  **简单来说**：

  MyBatis：小巧、方便、高效、简单、直接、半自动

  Hibernate：强大、方便、高效、复杂、绕弯子、全自动