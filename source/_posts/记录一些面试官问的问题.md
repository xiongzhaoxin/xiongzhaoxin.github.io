# 记录一些面试官问的问题

> 今天和同事去深职院校招，面试官总结一下面试官问到的问题
>
> 1. SQL练习1：统计班级男女生人数
>
>    1 有如下表格和数据:
>     2   ID     Name    Class   Sex
>     3   ----------- ---------- ---------- ----
>     4   **1**      张1     一班     男
>     5   **2**      张2     一班     男
>     6   **3**      张3     二班     女
>     7   **4**      张4     一班     男
>     8   **5**      张5     二班     女
>     9   **6**      张6     二班     女
>    10   **7**      张7     二班     男
>    11   **8**      张8     一班     女
>    12 现要求通过SELECT语句查询出如下结果：
>    13 
>    14   班级     男      女
>    15   ---------- ----------- -----------
>    16   二班     **1**      **3**
>    17   一班     **3**      **1**
>
>    要求一条语句查询

**个人解答**

```sql
select a.class 班级,a.nan 男生人数,b.nv 女生人数
from (select count(ID) nan,class from student where Sex ="男" group by class) as a,
	(select (count(ID) nv from student where Sex ="女" group by class))as b
```

> 我想到的方法是这个，我前两天刚好看到力扣这个方法，感觉是可以行的通的。

### 问题二

> 假设我有一个五升的水杯和一个六升的，那么请问，我如何获取一个三升的水

**个人解答**

> 获取三升的水，一个挺简单的逻辑题，首先六升灌满水，倒给五升，那么就还剩一升的水。然后吧五升的水倒掉，在倒入这个一升水。然后六升在灌满，倒给五升，这样就于二升。在重复一次，这样就获取了一个三升的水。

### 问题三

> 假设我打开一个分页，需要100秒，那么有什么方法或数据库可以优化他的查询速度呢？

**个人解答**

> 当时我想的是给数据建立一个索引，或者使用视图。这个可以大大提升数据库的查询效率。在网细了可以说使用Redis缓存来优化查询，这样就是查询键值对，速度很快，缓解数据库压力。以上就是我所能想到的，也不知道对不对...

### 问题四

> 假设我有一页面，上面有两个按钮，同时按下去，怎么保证他们的安全性问题（id都是一样的）

**个人解答**

> 可以使用 syschronized来保证线程安全（我也只会这个了）。同事说可以使用uuid这个说永远不会重复的id值来保证id不相同，不过好像跑题了....或者使用redis缓存这个具有事务原子性（想一想感觉也不对，ID都是相同的....） 不太明确百度也没有啥答案....

### 问题五

>  如果我在一个事务里，调用另一个事务，那会怎么样？

**个人解答**

> 这个真不会，百度了一下他是这样说的

> Spring对事务控制的支持统一在TransactionDefinition类中描述，该类有以下  几个重要的接口方法：
>
>   int getPropagationBehavior()：事务的传播行为
>   int getIsolationLevel()：事务的隔离级别
>   int getTimeout()：事务的过期时间
>   boolean isReadOnly()：事务的读写特性
>
> 这个属于事务传播行为，大概就是吧这两个事务默认当成一个事务，然后执行
>
> 
>
> Spring事务传播属性:
> 1.propagation-required: 支持当前事务,如果有就加入当前事务中;如果当前方法没有事务,就新建一个事务;
> 2.propagation-supports: 支持当前事务,如果有就加入当前事务中;如果当前方法没有事务,就以非事务的方式执行;
> 3.propagation-mandatory: 支持当前事务,如果有就加入当前事务中;如果当前没有事务,就抛出异常;
> 4.propagation-requires_new: 新建事务,如果当前存在事务,就把当前事务挂起;如果当前方法没有事务,就新建事务;
> 5.propagation-not-supported: 以非事务方式执行,如果当前方法存在事务就挂起当前事务;如果当前方法不存在事务,就以非事务方式执行;
> 6.propagation-never: 以非事务方式执行,如果当前方法存在事务就抛出异常;如果当前方法不存在事务,就以非事务方式执行;
> 7.propagation-nested: 如果当前方法有事务,则在嵌套事务内执行;如果当前方法没有事务,则与required操作类似;
> 前六个策略类似于EJB CMT，第七个（PROPAGATION_NESTED）是Spring所提供的一个特殊变量。
> 它要求事务管理器或者使用JDBC 3.0 Savepoint API提供嵌套事务行为（如Spring的DataSourceTransactionManager）

**以上文章摘自CSDN附上原文[链接](https://blog.csdn.net/levae1024/article/details/82998386?utm_source=blogxgwz1)**

